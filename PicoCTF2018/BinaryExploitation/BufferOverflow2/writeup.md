## PicoCTF 2018 | Binary Exploitation | Buffer Overflow 2
##### Author: Sanduuz | Date: 04.07.2019
---
### Challenge details:
* Points: 250
* Solves: 1551
* Description:<big><pre>
Alright, this time you'll need to control some arguments.
Can you get the flag from this [program](https://2018shell.picoctf.com/static/8ec59d858594f0e03108cf12e6177682/vuln)?
You can find it in /problems/buffer-overflow-2_2_46efeb3c5734b3787811f1d377efbefa on the shell server.
[Source](https://2018shell.picoctf.com/static/8ec59d858594f0e03108cf12e6177682/vuln.c).
</pre></big>
* Hint:<big><pre>
Try using gdb to print out the stack once you write to it!
</big></pre>

---

### Writeup:

**TL;DR**\
**Overwrite the return address and 2 parameters in order to retrieve the flag.**

This challenge is quite similar to `Buffer Overflow 1` with some additional challenge to it.\
(I recommend reading [`Buffer Overflow 1 Writeup`](https://github.com/Sanduuz/CTFWriteUps/PicoCTF2018/BinaryExploitation/BufferOverflow1/writeup.md) first)

We are given a 32-bit binary and the source code for it. To gain a better understanding of the program's control flow, I open the source code in a new window and run the binary while simultaneously reading the code.

Source code | Vulnerable binary
:----------:|:-----------------:
![source code](https://raw.githubusercontent.com/Sanduuz/CTFWriteUps/master/PicoCTF2018/BinaryExploitation/BufferOverflow2/attachments/source.png) | ![vulnerable binary](https://raw.githubusercontent.com/Sanduuz/CTFWriteUps/master/PicoCTF2018/BinaryExploitation/BufferOverflow2/attachments/vuln.png)

##### Note: In order to exploit the vulnerable program locally, you will need to create a file called `flag.txt` with a fake flag inside. In order to get the real flag you have to exploit the vulnerable program in the shell server.

So let's debug the code first.\
In the very beginning some libraries are being imported but those can be ignored. After that, few variables are defined. _**BUFSIZE**_ with the value of 100 and _**FLAGSIZE**_ with the value of 64. The _**FLAGSIZE**_ can also be ignored (just make sure your fake flag is not over 64 characters long). After those variables are defined, the rest of the code is just defining the functions.

Now starting from the `main` function, it can be seen that the program sets some gid bits. This is because the program is an _**SUID binary**_ meaning that it has **elevated permissions** during execution. SUID binaries are used in actions which require higher privileges than the normal user has. These include actions such as changing a password. The program requires elevated privileges in order to read the `flag.txt` file because our user has no permissions to do so.

After the permissions have been handled the program prints a string `"Please enter your string: "` to _stdout_ and then calls for the `vuln` function. In `vuln` a **buffer** is created with the size of _**BUFSIZE**_ which is 100 bytes. After that the program reads our input from _stdin_ and **stores** it into the **buffer**. Our input is reflected back to us and the program exits.

That seems to be all about program flow, but what about the `win` function you might ask? We need to exploit a _**buffer overflow**_ vulnerability in the `vuln` function as the name tells us. A _**buffer overflow**_ is an anomaly where a buffer in the program is filled with too much data resulting in the overflowing and overwriting of data.

This leads us to a thing called _**stack**_. What is a _**stack**_?\
Stack is a segment in computer memory. There are other segments such as text, data, bss and heap. Segments like text hold the code that is executed and it is read-only so the data in those segments can not be overwritten. However in stack, the data is not read-only so it can be overwritten. The stack might be a bit confusing at first because it grows _'upside down'_ towards lower memory addresses. Now how can we access the `win` function when it's never called in our program? When a function call in program is done, some things are going on in the stack.

1. A _stack frame_ for the function is created and pushed onto the stack. Inside the _stack frame_ is the data that the function needs. In addition to parameters that the function might take, there's also a _**return address (RET)**_ and a _**stack frame pointer (SFP)**_. _**Return address (RET)**_ is the address in memory where the function will return after execution. _**Stack frame pointer (SFP)**_ is the value of _base pointer (BP)_ and is used to restore the value of _base pointer (BP)_ after execution.
2. The current value of _stack pointer (SP)_ is copied to _base pointer (BP)_
3. Memory is allocated on the stack for the local variables of the function. (In the `win` function for example the flag buffer)

When calling the `vuln` function, the stack should look something like this:
![Stack](https://raw.githubusercontent.com/Sanduuz/CTFWriteUps/master/PicoCTF2018/BinaryExploitation/BufferOverflow2/attachments/stack.png)

This can be confirmed by running the program in a debugger such as GDB and inspecting the stack after supplying our string.
![Vulnerable assembly]()
