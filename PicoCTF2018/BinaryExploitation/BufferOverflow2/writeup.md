## PicoCTF 2018 | Binary Exploitation | Buffer Overflow 2
##### Author: Sanduuz | Date: 03.07.2019
---
### Challenge details:
* Points: 250
* Solves: 1546
* Description:<big><pre>
Alright, this time you'll need to control some arguments.
Can you get the flag from this [program](https://2018shell.picoctf.com/static/8ec59d858594f0e03108cf12e6177682/vuln)?
You can find it in /problems/buffer-overflow-2_2_46efeb3c5734b3787811f1d377efbefa on the shell server.
[Source](https://2018shell.picoctf.com/static/8ec59d858594f0e03108cf12e6177682/vuln.c).
</pre></big>
* Hint:<big><pre>
Try using gdb to print out the stack once you write to it!
</big></pre>

---

### Writeup:

**TL;DR**\
**Overwrite the return address and 2 parameters in order to retrieve the flag.**

This challenge is quite similar to `Buffer Overflow 1` with some additional challenge to it.\
(I recommend reading [`Buffer Overflow 1 Writeup`](https://github.com/Sanduuz/CTFWriteUps/PicoCTF2018/BinaryExploitation/BufferOverflow1/writeup.md) first)

We are given a 32-bit binary and the source code for it. To gain a better understanding of the program's control flow, I open the source code in a new window and run the binary while simultaneously reading the code.

Source code | Vulnerable binary
:----------:|:-----------------:
![source code](https://raw.githubusercontent.com/Sanduuz/CTFWriteUps/master/PicoCTF2018/BinaryExploitation/BufferOverflow2/attachments/source.png) | ![vulnerable binary](https://raw.githubusercontent.com/Sanduuz/CTFWriteUps/master/PicoCTF2018/BinaryExploitation/BufferOverflow2/attachments/vuln.png)

##### Note: In order to exploit the vulnerable program locally, you will need to create a file called `flag.txt` with a fake flag inside. In order to get the real flag you have to exploit the vulnerable program in the shell server.

So let's debug the code first.\
In the very beginning some libraries are being imported but those can be ignored. After that, few variables are defined. _**BUFSIZE**_ with the value of 100 and _**FLAGSIZE**_ with the value of 64. The _**FLAGSIZE**_ can also be ignored (just make sure your fake flag is not over 64 characters long). After those variables are defined, the rest of the code is just defining the functions.

Now starting from the `main` function, it can be seen that the program sets some gid bits. This is because the program is an _**SUID binary**_ meaning that it has **elevated permissions** during execution. SUID binaries are used in actions which require higher privileges than the normal user has. These include actions such as changing a password. The program requires elevated privileges in order to read the `flag.txt` file because our user has no permissions to do so.

After the permissions have been handled the program prints a string `"Please enter your string: "` to stdout and then calls for the `vuln` function. In `vuln` a **buffer** is created with the size of _**BUFSIZE**_ which is 100 bytes.
